


**正文**



**“公平锁”与“非公平锁”**



公平锁:指线程在等待获取同一个锁的时候，是严格按照申请锁的时间顺序来进行的，这就意味着在程序正常运作的时候，不会有线程执行不到，而被“饿死”，但是也需要额外的机制来维护这种顺序，所以效率相对于非公平锁会差点。

非公平锁：概念跟“公平锁”恰恰相反，随机线程获取锁，相率相对高。


```java
new ReentrantLock(); //默认非公平锁
new ReentrantLock(true); //公平锁
```


**“重入锁(递归锁)”与“不可重入锁（自旋锁）”** 不可重入锁：要unlock  
重入锁：当一个线程获取了A锁以后，若后续方法运行被A锁锁住的话，当前线程也是可以直接进入的。


```java
public class Demo {
  private Lock lockA;
 
  public Demo(Lock Lock) {
    this.lockA = lock;
  }
 
  public void methodA() {
    lockA.lock();
    methodB();
    lockA.unlock();
  }
 
  public void methodB() {
    lockA.lock();
    //dosm
    lockA.unlock();
  }
  
  }
```

当我们运行methodA()的时候，线程获取了lockA，然后调用methodB()的时候发现也需要lockA，由于这是一个可重入锁，所以当前线程也是可以直接进入的。在java中，synchronized跟ReetrantLock都是可重入锁。


  
以上面的代码实例来说明，就是methodA进入methodB的时候不能直接获取锁，必须先调用unLock释放锁。才能执行下去，那实现不可重入锁有什么方式呢？那就是自旋


```java
public class SpinLock {

  private AtomicReference<Thread> sign =new AtomicReference<>();

  public void lock(){
    Thread current = Thread.currentThread();
    while(!sign .compareAndSet(null, current)){
    }
  }

  public void unlock (){
    Thread current = Thread.currentThread();
    sign .compareAndSet(current, null);
  }
}
```

**“悲观锁”与“乐观锁”**

悲观锁：有一个“悲观”的心态，既每次取数据的时候，加一把锁才安心。乐观不会



并发的程度。

乐观锁：乐观的孩子，认为同一个数据不会发生并发操作的行为，所以取的时候不会加锁，只有在更新的时候，会通过例如版本号之类的来判断是否数据被修改了。



Java中各种锁其实都是悲观锁的实现，既操作的数据的都会被获取锁的线程锁住，而乐观锁的话，一般是通过cas（compare and swap）的思想来实现，例如一些原子类AtomicInteger使用自旋来原子更新。



**“共享锁” 只能加共享 与“排他锁” 不能再加其它锁**



共享锁：也称读锁或S锁。如果事务对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。
在java中的ReetrantReadWriteLock()也是如此。



排它锁：也称独占锁、写锁或X锁。如果事务对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。


这两种锁的概念比较多的出现在数据库



**分布式锁**

我们上面聊的这些锁，都是在单个程序上面的不同线程之间来实现的，那么当我们的不同程序需要去竞争同一块资源的时候，这就需要分布式锁了，我们可以通过redis、zookeeper

对于锁来说，其实还有偏向锁，轻量级锁等，但是这里涉及到的内容就比较多，这里就不在展开篇幅介绍了，有兴趣的同学可自行研究，如果你能搞懂上面介绍的这些锁，那基本上在绝大部分的公司关于“锁”的问题都可以迎刃而解。


<p align="center">
有收获的话，就分享给更多的朋友吧<br/>
<b>关注「深夜里的程序猿」，分享最干的干货</b>
</p>
<p align="center">
<img src="/resource/qrcode.png" alt="Sample"  width="200" height="200">
</p>
